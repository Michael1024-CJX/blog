1. 介绍分库分表的需求
2. 分库分表的方式
3. 分库分表需要考虑的问题
4. 不同的分片算法。
5. 介绍SharingSphere-JDBC和SharingSphere-Proxy的功能、原理。
	1. 数据迁移
	2. 数据分片
6. SharingSphere的限制


# 分库分表

## 为何需要分库分表
数据库通常都是一个系统的性能瓶颈，读写都涉及磁盘IO，比较耗性能。数据库出现性能瓶颈，会出现SQL执行变慢，上层应用请求堆积，可能会压垮应用。

当发现数据库变慢的时候，就需要考虑对其进行优化，优化总体有两个方向，一是从硬件层面解决，二是从软件层面解决。
硬件层面主要是提升**硬件性能**，磁盘I/O效率等，比如把机械硬盘改成固态硬盘，通常硬件层面的升级比较贵。
软件层面则可以通过：**SQL调优**，**读写分离**，**分库分表**，**增加缓存**等。
可以根据具体的项目情况，选择合适的方案去解决。

分库分表主要用来解决两个问题：
1. 一是单表或单库数据量过大，一次查询消耗的时间过多导致请求挤压。
2. 二是并发请求过大，导致数据库资源不足，无法处理过多的请求。


### 单表数据量过大
单表数据量过大可能造成**跨页**，**索引膨胀**，**索引层级过高**等问题。阿里巴巴《Java 开发手册》提出单表行数超过 **500 万行**或者单表容量超过 **2GB**，才推荐进行分库分表。

> 跨页：磁盘读取通过预读来提升性能，通常会连续读入3个缓存页，减少访问磁盘的次数。缓存页默认32位系统4k，64位系统8k。
> 
> 索引膨胀：主要针对PG的B-Tree。PG的删除更新不会真正的删除或更新，而是标记为死元祖，乱序写入或大量删除会引起索引膨胀。可以通过重建索引解决。


#### 单库数据量过大
单库数据过大会给磁盘压力，减低IO效率，磁盘碎片过多等问题。对于单一库大小，通常没有合适的定义，因为库的性能主要是由表和并发引起的，在**1TB**以内都是没问题的。


#### 并发请求过大
单台服务器的TPS、内存、IO都是有限的，如果并发访问过大很容易造成IO阻塞，然后堆积的请求越来越多，可能压垮数据库。

MYSQL 的并发在硬件配置还行的情况下, 能接受4000-5000的并发，但PG的并发性能就弱很多，PG14中进行了优化，只是400-500左右的并发。


## 分库分表的方式
### 垂直
垂直拆有垂直拆表和垂直拆库两种，通常垂直拆分都会影响业务系统的代码。

对于垂直拆表，就是把一张表拆成多张表，每张表保存部分字段，通过主键外键关联。垂直拆表可以解决表单行数据过大的情况，但通常效果并不明显。

垂直拆库则是需要进行领域划分，把不同业务系统的表拆成不同的库，并把库部署在不同的服务器上。
![](Pasted%20image%2020220824140217.png)

### 水平
水平拆表通常需要结合拆库一起做，将大表按照一定的逻辑进行拆分，拆分到不同的库上。每个库中保存的表结构都是一样的，但只保存部分的表数据。


## 分库分表需要考虑问题
1. 架构层面，分库分表是多主架构，增加节点就会增加系统的不稳定性，需要进行高可用的配置，如给每个主都配备一两个从节点。
2. 事务问题，单库中能使用本地事务，但多库就只能通过分布式事务来实现事务。
3. 分布式ID。
4. 跨库的关联查询，水平分库可能把相关的数据分到不同的库。
5. 排序、分页、分组、函数计算等功能不能直接使用了。
6. 多数据源切换。
7. 运维


## 开源的解决方案
- Atlas：不能实现分布式分表，所有的子表必须在同一台DB的同一个database里且所有的子表必须事先建好，Atlas没有自动建表的功能。[Atlas参考链接](https://link.zhihu.com/?target=http%3A//www.th7.cn/db/mysql/201406/59016.shtml)
- Cobar：必须将拆分后的表分别放入不同的库来实现分布式。[Cobar参考链接](https://link.zhihu.com/?target=https%3A//88250.b3log.org/alibaba-cobar-survey)
- TDDL：阿里，功能强大，过于复杂，部分开源。需要评估使用情况，防止过剩。
- Mycat ：国内开源，只适用于MySQL，从入门到放弃。[mycat参考链接](https://link.zhihu.com/?target=https%3A//github.com/myCATApache)
- heisenberg：百度开源，相对简单，易于管理。[heisenberg参考链接](https://link.zhihu.com/?target=https%3A//github.com/songwie/heisenberg)
- Oceanus：功能强大，开源，简化开发和配置成功。但产品还不成熟。
- vitess：google产品，集群基于ZooKeeper管理，通过RPC方式进行数据处理，可支撑高流量，它还添加了一个连接池，具有基于行的高速缓存，重写SQL查询，更安全。[vitess参考链接](https://link.zhihu.com/?target=https%3A//github.com/youtube/vitess)
- OneProxy：中国厂商产品，稳定性待确认。[OneProxy参考链接](https://link.zhihu.com/?target=http%3A//blog.csdn.net/wjc19911118/article/details/51375196)
- Sharding-JDBC：当当最新开源，jdbc层面操作。[Sharding-JDBC参考链接](https://link.zhihu.com/?target=http%3A//shardingjdbc.io/docs_cn/00-overview/)
- ShardingSphere：Apache开源的分布式数据库生态项目，是Sharding-JDBC和Sharding-Proxy的结合，目前在考虑引入Sharding-Sidecar。[ShardingSphere官方文档](https://shardingsphere.apache.org/document/current/cn/)


## 分片算法
分片算法都是根据特定的列，将数据以不同的规则分到不同的表中。
不同的分片算法会影响查询效率，需要根据实际的业务场景来选择合适的算法。

### 有序分片
#### 范围
以一个有序列作为分片的列，比如整型，时间等，按固定的数量拆分表。比如500w条，拆成每100w一张表，那么这里就可以拆出来5张表，每填满一张表，继续创建一张新的表。

适合数据增长可预估、冷热数据的场景。
**优点**是数据有序连续，分片算法简单，定位容易。
**缺点**是表的数量会动态增加。

#### 日表、月表
每天，或每个月创建一张表，跟时间有关。适合量比较大，且具有冷热性的数据。

缺点是表的数量会比较多。

#### 地理区域
将数据按照公司业务的地理范围进行划分，比如华南、华北、华东、华西等。这需要提前记录好数据所属的地理区域。


### 无序分片
#### 取模
以整型为列，与分表的数量进行取模运算。运算结构就是数据的桶位置。

**优点**是实现简单，数据分散，表数量固定。
**缺点**是依赖列的类型，乱序，有关联的数据可能被分到不同的表中。

### Hash取模
解决了取模算法依赖整型列的问题，可以对任意的列进行Hash运算得到整型数据。

#### 基因ID取模
基因ID能够解决取模分片中，相关数据被分到不同表中的问题。

