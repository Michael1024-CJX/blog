-   Date: 2022-08-24
-   Author: Michael
-   Keyword: #db 

# 分库分表
## What
也叫分片（Sharing）。
分库就是把一个数据库拆分成多个数据库，分表就是把一张表拆成多张表。
具体有两种拆分法，水平拆分（横向），垂直拆分（纵向）。 

分库也是一种多主架构，但是与传统的主从模式中的多主不同，主从模式中主从之间需要同步数据，多主之间也需要同步数据。而分库的多个主库之间不会同步数据，只有存在主从之间的同步。

### 分表
#### 水平拆分
对于水平拆表，就是不改变表结构，将表中的数据拆分到多张表中，多张表有一样字段，只是保存的数据不同。

### 垂直拆分
对于垂直拆表，就是把一张表拆成多张表，每张表保存部分字段，通过主键外键关联。

![](Pasted%20image%2020220824140217.png)

### 分库
#### 水平拆分
对于水平拆库，就是把库里的表数据拆到多个库中，每个库的表结构都一样，表中保存的都是部分数据。

### 垂直拆分
对于垂直拆库，就是把一个库中的表，分到不同的库，通常需要进行**领域划分**，避免需要关联的表被分到其他库。


---
## Why
数据库通常都是一个系统的性能瓶颈，读写都涉及磁盘IO，比较耗性能。数据库出现性能瓶颈，会出现SQL执行变慢，大量请求阻塞。

### 优化的方式
总体有两个方面，一是从硬件层面解决，二是从软件层面解决。
硬件层面主要是提升**硬件性能**，磁盘I/O效率等，比如把机械硬盘改成固态硬盘，通常硬件层面的升级比较贵。
软件层面则可以通过：**SQL调优**，**读写分离**，**分库分表**，**增加缓存**等。
可以根据具体的项目情况，选择合适的方案去解决。

分库分表主要用来解决两个问题：
1. 一是单表或单库数据量过大，一次查询消耗的时间过多导致请求挤压。
2. 二是并发请求过大，导致数据库资源不足，无法处理过多的请求。


#### 单表数据量过大
单表数据量过大可能造成**跨页**，**索引膨胀**，**索引层级过高**等问题。

> 跨页：磁盘读取通过预读来提升性能，通常会连续读入3个缓存页，减少访问磁盘的次数。缓存页默认32位系统4k，64位系统8k。
> 
> 索引膨胀：主要针对PG的B-Tree。PG的删除更新不会真正的删除或更新，而是标记为死元祖，乱序写入或大量删除会引起索引膨胀。可以通过重建索引解决。

##### 多大才算大
阿里巴巴《Java 开发手册》提出单表行数超过 **500 万行**或者单表容量超过 **2GB**，才推荐进行分库分表。


#### 单库数据量过大
单库数据过大会给磁盘压力，减低IO效率，磁盘碎片过多等问题。

##### 多大才算大
对于单一库大小，通常没有合适的定义，因为库的性能主要是由单表和并发引起的，在**1TB**以内都是没问题的。


#### 并发请求过大
单台服务器的TPS、内存、IO都是有限的，如果并发访问过大很容易造成IO阻塞，然后堆积的请求越来越多，可能压垮数据库。

##### 多大才算大
通常数据库比较适合的连接数开到**200-300**就够了，对于数据库，通常也只能接收200左右的并发请求。

---

## How

### 单表数据量过大
针对行数据过大的情况，可以采用**垂直拆分**，将一些`Blob,Clob`字段单独用一张表存储，减少预读跨页情况。通常垂直拆分需要改变业务代码。

针对列数据过大的情况，可以采用**水平拆分**，将一张表分为多张表，具体的方法通常有以下几种：
- **hash拆分**：将主键与分表的数量取模，可以参考HashMap的实现方式。
- **范围拆分**：如果主键是整型，可以按范围把数据进行划分，比如100万一张表，每满100万的数据就新建一张表。
- **地理区域**：将数据按照公司业务的地理范围进行划分，比如华南、华北、华东、华西等。这需要提前记录好数据所属的地理区域。
- **时间**：按时间进行划分，适用于冷热数据的场景。
- **每日/月表**：如果业务体量非常大，可以考虑用每日一张表，或者每月一张表来区分，再加上历史表整合过去的数据。

==通常单库内的拆表效果并不明显，更多的还是将子表拆到不同的库中，来分担访问压力。==


### 单库数据量过大
如果一个库中同时存储了多个领域的数据，则可以进行领域划分。将库**垂直拆分**，把访问频率高，数据量大的领域单独拆出来一个库。

或者结合水平分表实现**水平分库**，将访问压力分散到不同的库上。

==注意分库需要把库放在不同的服务器上，才能减低磁盘、连接数、IO的压力。多个库放在同一台服务器上，依然无法解决硬件层面的压力问题。==


### 并发请求过大
并发请求过大，如果读请求明显大于写请求，可以采用**主从模式**，主库写，从库读，来分离读写请求，降低主库的压力。或者增加**缓存读**，提高缓存命中。

如果主库压力依然过大，则可以考虑分库。分库与多主不同，多主模式下，多主之间都保存全部的数据，通过同步来实现一致性，而分库则是每个库都保存一部分数据。


### 分库分表带来的复杂性

#### 跨库关联查询
通常会把一个领域内的表分在一个库中，但是如果有水平分表，则相关的数据可能被分到其他库里。

有几种方案可以解决：
- 字段冗余：把需要关联的字段放入主表中，避免 join 操作；
- 全局表：比如一些字典表可以在每个数据库中都放一份；
- 应用层组装：将基础数据查出来，通过应用程序计算组装；

#### 分布式事务
多库之间的事务问题。

#### 排序、分页、分组、函数计算问题
SQL中的`order by`, `group by`，`limit`，以及一些函数就不能直接使用了。

解决方案：
- 把排序字段、分组字段放入全局的Redis中，由Redis实现响应的功能。
- 通过多次查询，合并结果集后再次操作。

#### 分布式ID
分库后，数据库的自增ID就不能用了，需要引入分布式ID，或者UUID。

#### 多数据源
可以通过中间件，或者应用端适配的方式实现多数据源访问问题。


### 解决方案
- Atlas：不能实现分布式分表，所有的子表必须在同一台DB的同一个database里且所有的子表必须事先建好，Atlas没有自动建表的功能。[Atlas参考链接](https://link.zhihu.com/?target=http%3A//www.th7.cn/db/mysql/201406/59016.shtml)
- Cobar：必须将拆分后的表分别放入不同的库来实现分布式。[Cobar参考链接](https://link.zhihu.com/?target=https%3A//88250.b3log.org/alibaba-cobar-survey)
- TDDL：阿里，功能强大，过于复杂，部分开源。需要评估使用情况，防止过剩。
- Mycat ：国内开源，只适用于MySQL，从入门到放弃。[mycat参考链接](https://link.zhihu.com/?target=https%3A//github.com/myCATApache)
- heisenberg：百度开源，相对简单，易于管理。[heisenberg参考链接](https://link.zhihu.com/?target=https%3A//github.com/songwie/heisenberg)
- Oceanus：功能强大，开源，简化开发和配置成功。但产品还不成熟。
- vitess：google产品，集群基于ZooKeeper管理，通过RPC方式进行数据处理，可支撑高流量，它还添加了一个连接池，具有基于行的高速缓存，重写SQL查询，更安全。[vitess参考链接](https://link.zhihu.com/?target=https%3A//github.com/youtube/vitess)
- OneProxy：中国厂商产品，稳定性待确认。[OneProxy参考链接](https://link.zhihu.com/?target=http%3A//blog.csdn.net/wjc19911118/article/details/51375196)
- Sharding-JDBC：当当最新开源，jdbc层面操作。[Sharding-JDBC参考链接](https://link.zhihu.com/?target=http%3A//shardingjdbc.io/docs_cn/00-overview/)
- ShardingSphere：Apache开源的分布式数据库生态项目，是Sharding-JDBC和Sharding-Proxy的结合，目前在考虑引入Sharding-Sidecar。[ShardingSphere官方文档](https://shardingsphere.apache.org/document/current/cn/)
