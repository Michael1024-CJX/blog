-   Date: 2022-08-08
-   Author: Michael
-   Keyword: #事务 #并发 #db 

# 多版本并发控制（MVCC）
基于MVCC的并发控制为乐观机制。读写操作均不阻塞，等到提交的时候才检验是否有冲突，由于不存在锁，大大提升了并发性能，常见的数据库Oracle，PostgreSQL，MySQL(Innodb)都使用MVCC来控制并发。


## PostgreSQL中的实现
MVCC 通过保存数据在某个时间点的**快照**，并控制**元组**的可见性来实现。创建一个新的快照时，将收集当前正在执行的事务ID和已提交的最大事务ID。

PG为每一个事务分配一个递增的Int32整型作为**事务ID**，称为`xid`。
PG中每条行记录都会有隐藏的4个字段（默认不显示），称为元组，分别是`xmin`, `xmax`, `cmin`, `cmax`。其中cmin和cmax分别是插入和删除该**元组**的命令，在事务中的命令序列标识，xmin和xmax与事务对其他事务的可见性相关，xmin记录创建该行数据的事务ID，xmax保存删除该行的事务ID。

#### xmin影响可见性
插入数据时，将当前xid存储到xmin中。对于[读已提交](事务#读已提交（Read%20Committed）)的隔离级别，事务中只会看到当前已提交的最大事务ID。对于[可重复读](事务#可重复读（Repeatable%20Read）)和[序列化](事务.md#序列化（Serializable）)的隔离级别，看不到事务ID大于元组中`xmin`事务的修改。


#### xmax影响可见性
通过 xmax 值判断事务的更新操作和删除操作对其他事务 的可见性有这几种情况：
1) 如果没有设置`xmax`值，该行对其他事务总是可见的；
2) 如果它被设置为回滚事务的xid ，该行对其他事务也是可见的；
3) 如果它被设置为一个正在运行，没有`COMMIT`和`ROLLBACK`事务的xid, 该行对其他事务是可见的；
4) 如果它被设置为一个已提交的事务的 xid ，该行对在这个己提交事务之后发起的所有事务都是不可见的


### 索引膨胀现象
postgresql中的更新操作是采用先删除后插入的实现方式，当运行大量的update语句后，会出现索引膨胀现象，这时可以创建一个新的索引，然后把旧索引删除，通过`CREATE UNIQUE INDEX CONCURRENTLY`可以并行创建索引，并且不会锁表。

