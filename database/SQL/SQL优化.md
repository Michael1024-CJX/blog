# SQL优化核心思想

==只有大表才会产生性能问题！==

一、单表查询，当查询结果是返回表中5%以内的数据时，应该走索引，否则应该走全表扫描。根本原因在于回表[^3]，回表次数太多就不应该走索引，应该直接全表扫描。回表会进行大量的磁盘I/O。
二、


## 索引

### 聚簇索引和非聚簇索引
聚簇索引的叶子节点就是对应的行数据，而非聚簇索引的叶子节点只是rowid和索引列的数据。因此非聚簇索引可能发送回表。

聚簇索引一张表只能有一个，通常都是主键，没有主键时才会选择其他列（第一个唯一列，没有的话就用表内的隐藏列）。

### 什么样的列必须建立索引？
当一个列出现在where中，并且选择性[^1]大于20%时，就应该建立索引。当然只有大表有这种需求。

### 索引失效
-   like通配符可能导致索引失效。  
-   查询条件包含or，可能导致索引失效  
-   如何字段类型是字符串，where时一定用引号括起来，否则索引失效  
-   对索引列运算（如，+、-、\*、/），索引失效。  
-   联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。  
-   在索引列上使用mysql的内置函数，索引失效。  
-   索引字段上使用is null， is not null，可能导致索引失效。  
-   索引字段上使用（！= 或者 < >，not in）时，可能会导致索引失效。  
-   左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。  
-   mysql估计使用全表扫描要比使用索引快,则不使用索引。


[^1]: 选择性：基数[^2]和总行数的比值百分比。
[^2]: 基数：一列中不一样的数据数量，比如性别列只有男和女，那么基数就是2，主键列的基数等于表的总行数。
[^3]: 回表：索引会包含该列的键值以及键值对应行所在的rowid，通过索引中记录的rowid访问表中的数据就叫回表。这就意味着只有查询索引列才不会存在回表的问题，可以建立组合索引来解决这种问题。 

