-   Date: 2022-08-14
-   Author: Michael
-   Keyword: #redis 

# Redis集群
redis通过Hash分槽来将不同的key，存放到不同的集群节点上。并且要求主节点的数量是奇数，且每个主节点至少有一个从节点。客户端只能在主节点执行读写，如果从节点发起请求，则会重定向到主节点执行。

## 集群需要解决的问题
1. 如何分槽？
2. 端如何想集群发起请求？
	1. 端访问任意的节点，如果key对应的槽不属于该节点，则会重定向到正确的节点。
	2. 端可以缓存槽与节点的映射，并本地计算key属于哪个槽，从而直接发起正确的请求。
3. 某个节点故障后，该节点的数据如何处理？
	1. 从库升级为主库。
	2. 新主库的从库可以通过副本飘逸来获取。
4. 新增节点后如何重新分槽。
	1. 通过`CLUSTER`指令管理分槽。
5. 一条指令中处理多个key时，这些key分散在不同的节点该怎么处理？
	1. 如果key在不同的节点，redis不支持，会报错。
	2. 可以使用`hash tag`机制，即在key上使用`{xxx}`，如果key中包含了{}，则分槽算法只会计算括号中的值。这样能使这些key保存在一个节点上。 

## 原理
Redis将键空间分为了**16384**个slot，通过`CRC16(key) mod 16384`算法，能够计算出键对应的槽位置。
每个集群节点都会保存每个slot属于哪个节点，客户端可以任意访问一个节点，如果key存在该节点上则直接返回，如果不存在，redis-server会返回key所属槽的节点IP地址，由客户端重新发送请求。
通常Redis客户端会缓存slot和节点的映射，然后本地计算key所属的slot，这样就能够直接请求正确的节点，以避免多次请求。
如果节点因故障或者扩容导致重新分片，客户端请求了错误的节点后，节点会响应正确的重定向信息，此时客户端就可以更新缓存了。

> 为什么是16384个槽？
> https://github.com/antirez/redis/issues/2576 redis作者的回答
> 
> 16384 byte = 16kb，redis集群的主节点之间需要定期发送心跳包已告知彼此的存在。心跳包中包含了自己的槽信息`myslots`，是一个bitmap，大小为`CLUSTER_SOLTS/8`，因此如果消息体中，myslots占用2kb大小。并且作者认为16384的大小已经足够了，虽然`CRC16算法`能够支持存在`65536`个槽，但是这样myslots的大小就要扩大到8kb，作为心跳包来说太大了。


## 缺点
- Redis不具备**自动容错**和**恢复功能**，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复
- 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题
- Redis的主从复制采用全量复制，复制过程中主机会fork出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦
- Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。